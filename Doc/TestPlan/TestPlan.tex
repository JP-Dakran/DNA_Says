\documentclass[12pt, titlepage]{article}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{indentfirst}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}



\title{SE 3XA3: Test Plan\\DNA Says}
\author{Team \#10, Team Name: DNA
		\\ Kareem Abdel Mesih (abdelk2)
		\\ John-Paul Dakran (dakranj)
		\\ Shady Nessim (nessimss)
}
\date{\today}
\begin{document}
\maketitle
\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures
\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2016/10/25 & 1.0 & Addition of General Information section \\
2016/10/29 & 1.1 & Addition of Comparison to Existing Implementation section\\
\bottomrule
\end{tabularx}
\end{table}
\newpage
\pagenumbering{arabic}
\section{General Information}
\subsection{Purpose}

\par In the engineering process, verification and validation of the requirements outlined in the Software Requirements Specification (SRS) document is essential. This process is executed through a series of tests executed on the requirements to prove that the functionality of the game is correct. This document serves the purpose of outlining how the requirements will be validated and verified.
\\
\par The implementation of the game DNA Says consists of numerous functional capabilities. These functional capabilities range from detecting user input to outputting a correct sound at a precise given time. The complete set of requirements will be broken down into specific and simple tests to prove the functionality of each specific requirement. 


\subsection{Scope}

\par The main objective of this document is to outline an agreed upon set of tests that will be performed on the software system to validate its functionality. The scope of the testing for this game includes testing the animations, sounds, buttons, integration of the system, and all functional and non-functional requirements outline in the Software Requirements Specification (SRS) document.


\subsection{Acronyms, Abbreviations, and Symbols}
	
\begin{table}[hbp]
\caption{\textbf{Table of Abbreviations}} \label{Table}
\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Abbreviation} & \textbf{Definition} \\
\midrule
SRS & Software Requirement Specification\\
PoC & Proof of Concept\\
GUI & Graphical User Interface\\
\bottomrule
\end{tabularx}
\end{table}


\begin{table}[!htbp]
\caption{\textbf{Table of Definitions}} \label{Table}
\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Term} & \textbf{Definition}\\
\midrule
Term1 & Definition1\\
Term2 & Definition2\\
\bottomrule
\end{tabularx}
\end{table}	
\subsection{Overview of Document}

\par This document outlines a collection of information about the software system - DNA Says - that is in the process of creation. The test plan document begins by describing the software system and its functionality. It then proceeds to introducing the reader with the test team and the plan for testing - I.e. Testing tools and the testing schedule.
\\
\par Next, the tests for functional and non-functional requirements will be described. Each test will have a type, initial state, input, output, and description of how the test will be performed. The same format will be used for the next section which outlines the tests for the proof of concept.
\\
\par Proceeding, the reader will be introduced to a concise comparison between the original implementation and the implementation that is currently in the process of creation. Next the unit testing plan will be revealed to the reader which describes the unit testing of the internal functions and output files. The test plan document will be concluded by the appendix which will hold a list of symbolic parameters and survey questions for user testing.


\section{Plan}
\par This section provides information about the plan for testing. It includes description of software, testing members as well as other details on tools and automation for testing. Provided at the end is a link to testing schedule on the Gantt chart.
\subsection{Software Description}
This software is a game adapted from the popular game Simon Says. Three modes are provided, each with a different style of pattern matching, user shall observe visual/audio pattern  and reproduce the pattern, then the pattern will be extended and so on.
\subsection{Test Team}
The test team consists of:
\begin{itemize}
  \item Kareem Abdel Mesih
  \item John-Paul Dakran
  \item Shady Nessim
\end{itemize}
Family and friends will also be involved in the testing process through user surveys.

\subsection{Automated Testing Approach}
\subsection{Testing Tools}
\subsection{Testing Schedule}
		
See Gantt Chart at the following url ...
\section{System Test Description}
	
\subsection{Tests for Functional Requirements}

\subsubsection{User Input}
		
\begin{itemize}

\item \textbf{Test \#1: REQ}
\begin{itemize}
\item Test ID: FT-UI-1
\item Type: Functional, Dynamic, Manual, Static etc.				
\item Initial State: 					
\item Input: 					
\item Output: 					
\item Execution (How test will be performed): 
\end{itemize}
					
\item \textbf{Test \#2: REQ}
\begin{itemize}
\item Test ID: FT-UI-2
\item Type: Functional, Dynamic, Manual, Static etc.				
\item Initial State: 					
\item Input: 					
\item Output: 					
\item Execution (How test will be performed): 
\end{itemize}


\end{itemize}

\subsubsection{Navigation}
...

\subsubsection{Display}

\subsubsection{Functionality}

\subsubsection{Constraints}



\subsection{Tests for Nonfunctional Requirements}
\subsubsection{Area of Testing1}

\begin{itemize}

\item \textbf{Test \#1: REQ}
\begin{itemize}
\item Test ID: 
\item Type: Functional, Dynamic, Manual, Static etc.				
\item Initial State: 					
\item Input: 					
\item Output: 					
\item Execution (How test will be performed): 
\end{itemize}

					
\item \textbf{Test \#2: REQ}
\begin{itemize}
\item Test ID: 
\item Type: Functional, Dynamic, Manual, Static etc.				
\item Initial State: 					
\item Input: 					
\item Output: 					
\item Execution: 
\end{itemize}

\end{itemize}
\subsubsection{Area of Testing2}
...
\section{Tests for Proof of Concept}
\subsection{Area of Testing1}
		
\paragraph{Title for Test}
\begin{enumerate}
\item{test-id1\\}
Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 
					
\item{test-id2\\}
Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 
\end{enumerate}
\subsection{Area of Testing2}
...
	
\section{Comparison to Existing Implementation}	

\par The implementation of DNA Says and Simon Says have many similarities and differences that will be outlined in this section. The main principle of the game stays constant however there are many improvements and modifications that have been added to truly make DNA Says unique. 
\\
\par The first significant difference between DNA Says and Simon Says is the fact that DNA Says has three modes. The original version of Simon Says only has one mode or one level which consists of 4 buttons that display the pattern to the user. In contrast DNA Says has three levels or three modes - each with a different implementation but overall the same theory from the Simon Says implementation. The first mode - Kareem Says, consists of piano keys that will display the pattern to the user. The second mode - Shady Says, consists of 4 different coloured buttons that will display the pattern to the user. The final mode - JP Says, consists of 9 different coloured buttons that will display the pattern to the user. 
\\
\par The second critical difference between the two implementations is the 4 second timeout. The original implementation - Simon Says, has no timeout. This means when the user clicks a button and does not click the next button, the program will wait for the user to enter the next button. In contrast, DNAY Says has a 4 second timeout that is implemented. When a user clicks a button/key and does not click the next button within 4 seconds, the player loses.
\\
\par The third significant difference between DNA Says and Simon Says is the protocol the program displays to the user when an incorrect button/key is inputted. The original version - Simon Says - displays the correct button that should have been clicked along with a sound that indicates an incorrect key has been inputted. The implementation of DNA Says makes the entire screen flash white 3 times and outputs a harmonic combination of notes that indicate an incorrect input. 
\\
\par Along with all the differences that truly make the game DNA Says truly unique, there are numerous similarities as the essence of the game is the same. Both implementations of the game have a main menu that allow the user to enter a mode and play the game. During a game, there is a score icon which displays the current score and there is also an exit button which will allow the user to return to the main menu.  

				
\section{Unit Testing Plan}
		
\subsection{Unit testing of internal functions}
		
\subsection{Unit testing of output files}		
\bibliographystyle{plainnat}
\bibliography{SRS}
\newpage
\section{Appendix}
This is where you can place additional information.
\subsection{Symbolic Parameters}
The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.
\subsection{Usability Survey Questions?}
This is a section that would be appropriate for some teams.
\end{document}