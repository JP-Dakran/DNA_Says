\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Report\\DNA Says}

\author{Team 10, DNA
		\\ Kareem Abdel Mesih - abdelk2
		\\ John-Paul Dakran - dakranj
		\\ Shady Nessim - nessimss
}

\date{\today}

\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[h]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
01/12/16 & 1.0 & Addition of Comp. to Existing Imp.\\
01/12/16 & 1.1 & Addition of Automated Testing\\
02/12/16 & 1.2 & Addition of  Unit Testing\\
02/12/16 & 1.3 & Addition of Changes Due To Testing\\
02/12/16 & 2.0 & Revision Of The Sections Above\\

\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

\section{Functional Requirements Evaluation}

\subsection{User Input}

\begin{itemize}


\item \textbf{Test \#1: The user will be able to open the executable file.}
\begin{itemize}
\item Test ID: FT-UI-1
\item Type: Functional, Dynamic, Manual		
\item Initial State: Desktop will be open. 					
\item Input: Mouse click on DNA Says application icon. 					
\item Output: DNA Says's main menu will appear. 					
\item Execution: The tester will open the application on a CPU.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#2: The user will be able to select one of the three modes to play:} 
\begin{itemize}
\item Test ID: FT-UI-2
\item Type: Functional, Dynamic, Manual 		
\item Initial State: Main menu will be open. 					
\item Input: Mouse click on a desired mode. 					
\item Output: Redirection to that modes user interface.					
\item Execution: The tester will attempt to open each of the three modes via the main menu.
\item Result: Pass
\end{itemize}

\end{itemize}


\subsection{Navigation}

\begin{itemize}

\item \textbf{Test \#3: The user will be able to stop the game at any time and go back to the main menu.}
\begin{itemize}
\item Test ID: FT-NAV-1
\item Type: Functional, Dynamic, Manual 		
\item Initial State: One of the three modes will be open.					
\item Input: Mouse click on "Main Menu" icon.					
\item Output: User will be redirected to the main menu.					
\item Execution: The tester will play one of the modes and attempt to go back to the main menu via the "Main Menu" icon.
\item Result: Pass
\end{itemize}

\end{itemize}

\subsection{Display}

\begin{itemize}

\item \textbf{Test \#4: The game interface will open in a new window.}
\begin{itemize}
\item Test ID: FT-D-1
\item Type: Functional, Dynamic, Manual 		
\item Initial State: Desktop will be open. 				
\item Input: Mouse click on DNA Says application icon. 					
\item Output: A new window labelled DNA Says will open and the main menu will appear.  					
\item Execution: The tester will open the application on a CPU.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#5: The main menu will display the three different modes.}
\begin{itemize}
\item Test ID: FT-D-2
\item Type: Functional, Dynamic, Manual	
\item Initial State: Desktop will be open.					
\item Input: Mouse click on DNA Says application.					
\item Output: Main menu will open. 					
\item Execution: The tester will check if the three modes are available via the main menu.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#:6 Four different coloured buttons will be shown to the user during Shady Says.}
\begin{itemize}
\item Test ID: FT-D-3
\item Type: Functional, Dynamic, Manual		
\item Initial State: Main menu will be open.					
\item Input: Mouse click on Shady Says mode.					
\item Output: Shady Says mode will open and display the user interface.					
\item Execution: The tester will open the mode "Shady Says" and check if there are four different coloured buttons displayed.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#7: Each button will light up and produce a different sound when clicked.}
\begin{itemize}
\item Test ID: FT-D-4
\item Type: Functional, Dynamic, Manual 		
\item Initial State: One of the three modes will be open, and one of the buttons will light up and produce a sound.\item Input: Mouse click on the specific button that lit up. 					
\item Output: The specific button will light up and produce a sound.					
\item Execution: The tester will play the game and click one of the correct button with respect to the pattern and observe the behaviour.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#8: There will be a score box at the top right corner.}
\begin{itemize}
\item Test ID: FT-D-5
\item Type: Functional, Dynamic, Manual 		
\item Initial State: One of the three modes will be open. 					
\item Input: No input.					
\item Output: No output. 					
\item Execution: The user will enter one of the three modes and verify that there is a score icon at the top right corner.  
\item Result: Pass
\end{itemize}

\end{itemize}

\subsection{Functionality}

\begin{itemize}

\item \textbf{Test \#9: The game will have three separate modes- Kareem Says, JP Says, and Shady Says }
\begin{itemize}
\item Test ID: FT-FUNC-1
\item Type: Functional, Dynamic, Manual 		
\item Initial State: Desktop will be open.					
\item Input: Mouse click on DNA Says application	
\item Output: Main menu will open.					
\item Execution: The tester will check if the three modes are available via the main menu.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#10: Every time a user passes a level, the score goes up by one point.}
\begin{itemize}
\item Test ID: FT-FUNC-2
\item Type: Functional, Dynamic, Automated		
\item Initial State: One of the three modes will be open.					
\item Input: Mouse click on the pattern that the computer has displayed to the user.					
\item Output: The score icon will increase by 1 point. 					
\item Execution: The tester will play the game, they will attempt to produce the pattern and observe the score.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#11: Every time a user fails a level, the score is reset to zero.}
\begin{itemize}
\item Test ID: FT-FUNC-3
\item Type: Functional, Dynamic, Automated	
\item Initial State: One of the three modes will be open.					
\item Input: Mouse click on the incorrect button.					
\item Output: The score will be reset to zero and the screen will flash three times. 					
\item Execution: The tester will play the game, they will input the incorrect pattern and observe the score.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#12: At level N, a random pattern of N elements will light up and be displayed to the user. }
\begin{itemize}
\item Test ID: FT-FUNC-4
\item Type: Functional, Dynamic, Automated		
\item Initial State: One of the three modes will be open. 					
\item Input: No input				
\item Output: One button will light up and produce a sound.		
\item Execution: The user will attempt level one, and verify that one button lights up. They can also do this for further levels. 
\item Result: Pass
\end{itemize}

\item \textbf{Test \#13: The user cannot click on the buttons while the pattern is being displayed.}
\begin{itemize}
\item Test ID: FT-FUNC-5
\item Type: Functional, Dynamic, Manual	
\item Initial State: Level one of a mode will start.					
\item Input: Mouse click on a button. 					
\item Output: Sound played. 					
\item Execution: The tester will attempt to click on a button while the computer is displaying the pattern and observe the behaviour of the program.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#14: The user will be able to click on the buttons once the pattern has been displayed.}
\begin{itemize}
\item Test ID: FT-FUNC-6
\item Type: Functional, Dynamic, Manual	
\item Initial State: Level one of a mode will be start.					
\item Input: Mouse click on a button.					
\item Output: Correct button click- button will light up and produce a sound. Incorrect button- screen will flash three times and a harmonic sound will play to indicate wrong input. 					
\item Execution: After the pattern has been displayed, the tester will click the correct button and verify that it can be clicked. The tester will also click an incorrect button and verify that it can also be clicked.
\item Result: Pass
\end{itemize}

\item \textbf{Test \#15: A level is passed if the user repeats the pattern correctly.}
\begin{itemize}
\item Test ID: FT-FUNC-7
\item Type: Functional, Dynamic, Automated		
\item Initial State: Level N of a mode will be start. 					
\item Input: Mouse click on button that are part of the pattern the computer displayed to the user.  	
\item Output: After each correct click on a button, that specific button will light up and produce a sound. Also the score will increase by one when the correct pattern has been inputted completely. Then the next pattern will be displayed to the user. 					
\item Execution: The tester will play a level in a one of the three modes and entire the correct pattern. 
\item Result: Pass
\end{itemize}

\item \textbf{Test \#16: If the user fails, the game will restart- N =1.}
\begin{itemize}
\item Test ID: FT-FUNC-8
\item Type: Functional, Dynamic, Automated	
\item Initial State: One of the three modes will be open. 					
\item Input: Mouse click on an incorrect button. 					
\item Output: The screen will flash white three times, the score will be reset to 0 and the user will be redirected to level 1.
\item Execution: The tester will play the game, they will input the incorrect pattern. The user will verify that they are redirected to level 1.
\item Result: Pass
\end{itemize}

\end{itemize}

\subsection{Parallelism}

\section{Nonfunctional Requirements Evaluation}

\subsection{Usability}
		
\subsection{Performance}

\subsection{etc.}
	
\section{Comparison to Existing Implementation}	

\par The core functionality of DNA Says relies on the original game Simon Says. However, the implementation is vastly different to preserve originality and creativity. The main principle of having the computer play a specific pattern and having the user repeat it is evident in both implementations. It is how the pattern is presented that is modified in DNA Says, rather than having one mode that contains only four buttons. This is what makes DNA Says unique. 
\\
\par DNA Says contains three modes, compared to one, which are Kareem Says, JP Says and Shady Says. In Kareem Says, the user is presented a piano keyboard in which the pattern will be played on, both by the computer and the user. Of course, the colors of the keys match those of a real piano, and each key is assigned one unique tone. When a key is clicked, if it is correct then it will light up in red to indicate the selection and its tone will play. Otherwise, the whole window will flash to indicate the entry of a wrong key and losing the game and a harmonic combination of tones will play. This wil then reset back to level one, and the score to zero.
\\
\par As for JP Says, there are nine buttons of different colors, arranged as a three-by-three grid in the middle of the screen. Each button is assigned a unique tone that is played every time the button is pressed. To advance with this mode, the user must repeat the pattern that is played by the computer. The pattern is incremented by one element for every level. The new element that is added is completely random every time. Winning and losing conditions follow those of Kareem Says.
\\
\par Finally, Shady Says. There are four buttons of different colors, arranged as a two-by-two grid in the middle of the screen. For every time that any button is pressed, a completely random tone (out of four in total) will play. To advance with this mode, the user must repeat the pattern that is played by the computer. The pattern is incremented by one element for every level. The new element that is added is completely random every time. Winning and losing conditions follow those of Kareem Says.


\section{Unit Testing}

\par The program was split up into modules, each to be tested separately. This unit testing ensured that changes made to the game did not break the basic functionality of the game. The testing conducted is detailed below.

\begin{itemize}

\item \textbf {Test \#1}
\begin{itemize}
\item{Test: main}
\item{Type: manual}
\item{Description: checks if the program is initialized as required}
\item{Initial State: program not yet started}
\item{Input: the program is started}
\item{Output: Pygame is initialized, fonts and sounds are loaded, and required variables are made global}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#2}
\begin{itemize}
\item{Test: setup}
\item{Type: automated}
\item{Description: checks if the screen is refreshed and setup again with every transition}
\item{Initial State: either on the menu or in any mode}
\item{Input: if on the menu, then a mode is selected. If in any mode, then the back button is clicked}
\item{Output: transition to the desired screen is successful, without any left-overs from the previous screen}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#3}
\begin{itemize}
\item{Test: update}
\item{Type: automated}
\item{Description: checks if the screen is updated accordingly inside any mode}
\item{Initial State: in any mode, no changes appear on the screen yet}
\item{Input: The computer or user plays an element from the pattern}
\item{Output: the screen updates accordingly and displays that change}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#4}
\begin{itemize}
\item{Test: showInst}
\item{Type: manual}
\item{Description: checks if instructions are displayed on screen at the desired location}
\item{Initial State: the instruction are not shown on the screen}
\item{Input: showInst() is invoked}
\item{Output: the instructions appear at the bottom left corner}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#5}
\begin{itemize}
\item{Test: showGoBack}
\item{Type: manual}
\item{Description: checks if the back button text is displayed at the desired location}
\item{Initial State: the back button text is not shown on the screen}
\item{Input: showGoBack() is invoked}
\item{Output: the back button text appears at the top left corner}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#6}
\begin{itemize}
\item{Test: showScore}
\item{Type:manual }
\item{Description: checks if the score is displayed at the desired location}
\item{Initial State: the score is not shown on the screen}
\item{Input: showScore() is invoked}
\item{Output: the score appears at the top right corner}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#7}
\begin{itemize}
\item{Test: flashKeyAnimation}
\item{Type: automated}
\item{Description: checks if key animations are error proof with regards to wrong input}
\item{Initial State: game launched in any mode}
\item{Input: the computer or user plays an element from the pattern}
\item{Output: button visuals and associated sound, no output for inputs that are out of range}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#8}
\begin{itemize}
\item{Test: drawKeys}
\item{Type: automated}
\item{Description: checks if the correct buttons are drawn at their correct locations depending on the mode selected}
\item{Initial State: on the menu}
\item{Input: any mode is selected}
\item{Output: the correct buttons appear on the screen along with the back button, at their correct locations}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#9}
\begin{itemize}
\item{Test: changeBackgroundAnimation}
\item{Type: automated}
\item{Description: checks the changing of the background color after every level change}
\item{Initial State: game launches in any mode}
\item{Input: the user beats or loses a level}
\item{Output: the background changes accordingly}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#10}
\begin{itemize}
\item{Test: gameOverAnimation}
\item{Type: automated}
\item{Description: checks if the screen flashes when a user loses at any level}
\item{Initial State: the computer is waiting for the user's input}
\item{Input: the user enters a wrong element from the pattern that the computer played}
\item{Output: the screen flashes}
\item{Result: PASS!}
\end{itemize}

\item \textbf {Test \#11}
\begin{itemize}
\item{Test: checkForQuit}
\item{Type: manual}
\item{Description: checks if the program terminates when the quit button is clicked}
\item{Initial State: any screen is displayed}
\item{Input: checkForQuit() is invoked}
\item{Output: the program terminates}
\item{Result: PASS!}
\end{itemize}

\end{itemize}

\par The program does not produce any output files. Unit testing is therefore not applicable for output files in this project.

\section{Changes Due to Testing}
\begin{itemize}
\item \textbf {Note Release Time}
\par After playing the game, it was decided that the release time of the notes should be increased. The piano notes then were re-recorded to accommodate that decision.


\item \textbf {Button Colors in JP Says}
\par Rather than having different shades of a single color present, the team decided to follow a systematic order. It was decided that it would be best to have all seven colors of the rainbow present, along with black and white to have nine visually distinguishable colors/shades to use.

\item \textbf {Back Button}
\par After conducting the survey, it was agreed upon that the back button did not look elegant. Several individuals had suggested to simply display the word “Back” on the button rather than the left-pointing arrow.

\item \textbf {Redisplaying Text on Screen}
\par As the level changed (incremented or decremented), the text on the screen now flickers to indicate that change along with the change of colors in the background.

\item \textbf {Endless Playing}
\par The game has been changed to be able to reach an infinite level number. The user can continuously play until they lose or choose to stop playing for any circumstances. In addition, the song pattern in Kareem Says has been implemented in a way where the song will loop to the beginning uninterruptedly to accommodate that change.
\end{itemize}

\section{Automated Testing}

\par Generally, automated testing is not the most effective with games as there has not been a fixed artificial intelligence implementation that can mimic a human being’s behaviour exactly. However, as a team, automated testing was made a possibility (to an extent). For all three modes, a random selection algorithm was implemented to select a random button to play back to the computer after it displayed the pattern, that is biased towards picking the correct button. This can somewhat identify with the behaviour of a child playing this game. Another short algorithm was developed to then analyze the given input at every level and compare it to the pattern that the computer played. If it matched exactly then the test would advance to the next level. Otherwise, the mode resets back to level one.
\\
\par This program produces no output files and therefore automated testing for output files is not applicable.

		
\section{Trace to Requirements}
		
\section{Trace to Modules}		

\section{Code Coverage Metrics}

\par As an estimate, all tests including manual, automated and unit testing have covered ninety-five percent of the code written in the source file. Each method/module has been tested separately as well as coupled with other appropriate modules. This estimate holds true as all modules have been tested thoroughly with various inputs when applicable, and now the output of all remains correct as expected. Please refer to the Automated Testing and Unit Testing sections above to further validate the coverage rate estimate.

\bibliographystyle{plainnat}

\bibliography{SRS}

\end{document}