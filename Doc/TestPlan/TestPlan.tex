\documentclass[12pt, titlepage]{article}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{indentfirst}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}



\title{SE 3XA3: Test Plan\\DNA Says}
\author{Team \#10, Team Name: DNA
		\\ Kareem Abdel Mesih (abdelk2)
		\\ John-Paul Dakran (dakranj)
		\\ Shady Nessim (nessimss)
}
\date{\today}
\begin{document}
\maketitle
\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures
\begin{table}[bp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2016/10/25 & 1.0 & Addition of General Information section \\
2016/10/29 & 1.1 & Addition of Comparison to Existing Implementation section\\
\bottomrule
\end{tabularx}
\end{table}
\newpage
\pagenumbering{arabic}
\section{General Information}
\subsection{Purpose}

\par In the engineering process, verification and validation of the requirements outlined in the Software Requirements Specification (SRS) document is essential. This process is executed through a series of tests executed on the requirements to prove that the functionality of the game is correct. This document serves the purpose of outlining how the requirements will be validated and verified.
\\
\par The implementation of the game DNA Says consists of numerous functional capabilities. These functional capabilities range from detecting user input to outputting a correct sound at a precise given time. The complete set of requirements will be broken down into specific and simple tests to prove the functionality of each specific requirement. 


\subsection{Scope}

\par The main objective of this document is to outline an agreed upon set of tests that will be performed on the software system to validate its functionality. The scope of the testing for this game includes testing the animations, sounds, buttons, integration of the system, and all functional and non-functional requirements outline in the Software Requirements Specification (SRS) document.


\subsection{Acronyms, Abbreviations, and Symbols}
	
\begin{table}[hbp]
\caption{\textbf{Table of Abbreviations}} \label{Table}
\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Abbreviation} & \textbf{Definition} \\
\midrule
SRS & Software Requirement Specification\\
PoC & Proof of Concept\\
GUI & Graphical User Interface\\
\bottomrule
\end{tabularx}
\end{table}


\begin{table}[!htbp]
\caption{\textbf{Table of Definitions}} \label{Table}
\begin{tabularx}{\textwidth}{p{3cm}X}
\toprule
\textbf{Term} & \textbf{Definition}\\
\midrule
Term1 & Definition1\\
Term2 & Definition2\\
\bottomrule
\end{tabularx}
\end{table}	
\subsection{Overview of Document}

\par This document outlines a collection of information about the software system - DNA Says - that is in the process of creation. The test plan document begins by describing the software system and its functionality. It then proceeds to introducing the reader with the test team and the plan for testing - I.e. Testing tools and the testing schedule.
\\
\par Next, the tests for functional and non-functional requirements will be described. Each test will have a type, initial state, input, output, and description of how the test will be performed. The same format will be used for the next section which outlines the tests for the proof of concept.
\\
\par Proceeding, the reader will be introduced to a concise comparison between the original implementation and the implementation that is currently in the process of creation. Next the unit testing plan will be revealed to the reader which describes the unit testing of the internal functions and output files. The test plan document will be concluded by the appendix which will hold a list of symbolic parameters and survey questions for user testing.


\section{Plan}
\par This section provides information about the plan for testing. It includes description of software, testing members as well as other details on tools and automation for testing. Provided at the end is a link to testing schedule on the Gantt chart.
\subsection{Software Description}
This software is a game adapted from the popular game Simon Says. Three modes are provided, each with a different style of pattern matching, user shall observe visual/audio pattern  and reproduce the pattern, then the pattern will be extended and so on.
\subsection{Test Team}
The test team consists of:
\begin{itemize}
  \item Kareem Abdel Mesih
  \item John-Paul Dakran
  \item Shady Nessim
\end{itemize}
Family and friends will also be involved in the testing process through user surveys.

\subsection{Automated Testing Approach}
\subsection{Testing Tools}
\subsection{Testing Schedule}
		
See Gantt Chart at the following url ...
\section{System Test Description}
	
\subsection{Tests for Functional Requirements}

\subsubsection{User Input}
		
\begin{itemize}

\item \textbf{Test \#1: The user will be able to open the executable file.}
\begin{itemize}
\item Test ID: FT-UI-1
\item \textbf{Type: Functional, Dynamic, Manual, Static etc.}				
\item Initial State: Desktop will be open. 					
\item Input: Mouse click on DNA Says application icon. 					
\item Output: DNA Says main menu will appear. 					
\item Execution (How test will be performed): The tester will open the application on a CPU.
\end{itemize}
					
\item \textbf{Test \#2: The user will be able to select one of the three modes to play:} 
\begin{itemize}
\item Test ID: FT-UI-2
\item Type: 		
\item Initial State: Main menu will be open. 					
\item Input: Mouse click on a desire mode. 					
\item Output: Redirection to that modes user interface.					
\item Execution: The tester will attempt to open each of the three modes via the main menu.
\end{itemize}


\end{itemize}

\subsubsection{Navigation}

\begin{itemize}

\item \textbf{Test \#3: The user will be able to exit the game at any time and go back to the main menu.}
\begin{itemize}
\item Test ID: FT-NAV-1
\item Type: 		
\item Initial State: One of the three modes will be open.					
\item Input: Mouse click on "Main Menu" icon.					
\item Output: User will be redirected to the main menu.					
\item Execution: The tester will play one of the modes and attempt to go back to the main menu via the "Main Menu" icon.
\end{itemize}

\end{itemize}

\subsubsection{Display}

\begin{itemize}

\item \textbf{Test \#4: The game interface will open in a new window.}
\begin{itemize}
\item Test ID: FT-D-1
\item Type: 		
\item Initial State: Desktop will be open. 				
\item Input: Mouse click on DNA Says application icon. 					
\item Output: A new window labelled DNA Says will open and the main menu will appear.  					
\item Execution: The tester will open the application on a CPU.
\end{itemize}

\item \textbf{Test \#5: The main menu will display the three different modes.}
\begin{itemize}
\item Test ID: FT-D-2
\item Type: 		
\item Initial State: Desktop will be open.					
\item Input: Mouse click on DNA Says application.					
\item Output: Main menu will open. 					
\item Execution: The tester will check if the three modes are available via the main menu.
\end{itemize}

\item \textbf{Test \#:6 Four different coloured disks will be shown to the user during Shady Says.}
\begin{itemize}
\item Test ID: FT-D-3
\item Type: 		
\item Initial State: Main menu will be open.					
\item Input: Mouse click on Shady Says mode.					
\item Output: Shady Says mode will open and display the user interface.					
\item Execution: The tester will open the mode - Shady Says - and check if there are four different coloured disks displayed.
\end{itemize}

\item \textbf{Test \#7: Each disk/key will light up and produce a different sound when clicked.}
\begin{itemize}
\item Test ID: FT-D-4
\item Type: 		
\item Initial State: One of the three modes will be open, and one of the disks/keys will light up and produce a sound.			
\item Input: Mouse click on the specific disk that lit up. 					
\item Output: The specific disk/key will light up and produce a sound.					
\item Execution: The tester will play the game and click one of the correct disks/keys with respect to the pattern and observe the behaviour.
\end{itemize}

\item \textbf{Test \#8: There will be a score icon in the bottom right corner.}
\begin{itemize}
\item Test ID: FT-D-5
\item Type: 		
\item Initial State: One of the three modes will be open. 					
\item Input: No input.					
\item Output: No output. 					
\item Execution: The user will enter one of the three modes and verify that there is a score icon in the bottom right corner.  
\end{itemize}

\end{itemize}

\subsubsection{Functionality}

\begin{itemize}

\item \textbf{Test \#9: The game will have 3 separate modes - Kareem Says, JP Says, and Shady Says }
\begin{itemize}
\item Test ID: FT-FUNC-1
\item Type: 		
\item Initial State: Desktop will be open.					
\item Input: Mouse click on DNA Says application	
\item Output: Main menu will open.					
\item Execution: The tester will check if the 3 modes are available via the main menu.
\end{itemize}

\item \textbf{Test \#10: Every time a user passes a level, the score goes up by one point.}
\begin{itemize}
\item Test ID: FT-FUNC-2
\item Type: 		
\item Initial State: One of the three modes will be open.					
\item Input: Mouse click on the pattern that the computer has displayed to the user.					
\item Output: The score icon will increase by 1 point. 					
\item Execution: The tester will play the game, they will attempt to produce the pattern and observe the score.
\end{itemize}

\item \textbf{Test \#11: Every time a user fails a level, the score is reset to zero.}
\begin{itemize}
\item Test ID: FT-FUNC-3
\item Type: 		
\item Initial State: One of the three modes will be open.					
\item Input: Mouse click on the incorrect pattern.					
\item Output: The score will be reset to zero and the screen will flash three times. 					
\item Execution: The tester will play the game, they will input the incorrect pattern and observe the score.
\end{itemize}

\item \textbf{Test \#12: At level N, a random pattern of N disks will light up and be displayed to the user. }
\begin{itemize}
\item Test ID: FT-FUNC-4
\item Type: 		
\item Initial State: One of the three modes will be open. 					
\item Input: No input				
\item Output: One disk/key will light up and produce a sound.		
\item Execution: The user will attempt level one, and verify that one key/disk lights up. They can also do this for further levels. 
\end{itemize}

\item \textbf{Test \#13: The user cannot click the disks while the pattern is being displayed.}
\begin{itemize}
\item Test ID: FT-FUNC-5
\item Type: 		
\item Initial State: Level one of a mode will be open.					
\item Input: Mouse click on a key/disk. 					
\item Output: No output. 					
\item Execution: The tester will attempt to click a key/disk while the computer is displaying the pattern and observe the behaviour of the program.
\end{itemize}

\item \textbf{Test \#14: The user will be able to click the disks once the pattern has been displayed.}
\begin{itemize}
\item Test ID: FT-FUNC-6
\item Type: 		
\item Initial State: Level one of a mode will be open.					
\item Input: Mouse click on a key/disk.					
\item Output: Correct key/disk click - Key/disk will light up and produce a sound. Incorrect key/disk - Screen will flash threee times. 					
\item Execution: After the pattern has been displayed, the tester will click the correct disk and verify that it can be clicked. The tester will also click an incorrect disk and verify that it can also be clicked.
\end{itemize}

\item \textbf{Test \#15: A level is passed if the user repeats the pattern correctly.}
\begin{itemize}
\item Test ID: FT-FUNC-7
\item Type: 		
\item Initial State: Level N of a mode will be open. 					
\item Input: Mouse click on key/disk that are part of the pattern the computer displayed to the user.  		
\item Output: After each correct click on a key/disk, that specific key/disk will light up and produce a sound. Also the score will increase by one when the correct pattern has been inputted completely. Then the next pattern will be displayed to the user. 					
\item Execution: The tester will play a level in a one of the three modes and entire the correct pattern. 
\end{itemize}

\item \textbf{Test \#16: If the user fails, the game will restart - I.e. N =1.}
\begin{itemize}
\item Test ID: FT-FUNC-8
\item Type: 		
\item Initial State: One of the three modes will be open. 					
\item Input: Mouse click on an incorrect disk/key. 					
\item Output: The screen will flash white three times, the score will be reset to 0 and the user will be redirected to level 0.					
\item Execution: The tester will play the game, they will input the incorrect pattern. The user will verify that they are redirected to level 1.
\end{itemize}



\end{itemize}




\subsection{Tests for Nonfunctional Requirements}
\subsubsection{Area of Testing1}

\begin{itemize}

\item \textbf{Test \#1: REQ}
\begin{itemize}
\item Test ID: 
\item Type: Functional, Dynamic, Manual, Static etc.				
\item Initial State: 					
\item Input: 					
\item Output: 					
\item Execution (How test will be performed): 
\end{itemize}

					
\item \textbf{Test \#2: REQ}
\begin{itemize}
\item Test ID: 
\item Type: Functional, Dynamic, Manual, Static etc.				
\item Initial State: 					
\item Input: 					
\item Output: 					
\item Execution: 
\end{itemize}

\end{itemize}
\subsubsection{Area of Testing2}
...
\section{Tests for Proof of Concept}
\subsection{Area of Testing1}
		
\paragraph{Title for Test}
\begin{enumerate}
\item{test-id1\\}
Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 
					
\item{test-id2\\}
Type: Functional, Dynamic, Manual, Static etc.
					
Initial State: 
					
Input: 
					
Output: 
					
How test will be performed: 
\end{enumerate}
\subsection{Area of Testing2}
...
	
\section{Comparison to Existing Implementation}	

\par The implementation of DNA Says and Simon Says have many similarities and differences that will be outlined in this section. The main principle of the game stays constant however there are many improvements and modifications that have been added to truly make DNA Says unique. 
\\
\par The first significant difference between DNA Says and Simon Says is the fact that DNA Says has three modes. The original version of Simon Says only has one mode or one level which consists of 4 buttons that display the pattern to the user. In contrast DNA Says has three levels or three modes - each with a different implementation but overall the same theory from the Simon Says implementation. The first mode - Kareem Says, consists of piano keys that will display the pattern to the user. The second mode - Shady Says, consists of 4 different coloured buttons that will display the pattern to the user. The final mode - JP Says, consists of 9 different coloured buttons that will display the pattern to the user. 
\\
\par The second critical difference between the two implementations is the 4 second timeout. The original implementation - Simon Says, has no timeout. This means when the user clicks a button and does not click the next button, the program will wait for the user to enter the next button. In contrast, DNAY Says has a 4 second timeout that is implemented. When a user clicks a button/key and does not click the next button within 4 seconds, the player loses.
\\
\par The third significant difference between DNA Says and Simon Says is the protocol the program displays to the user when an incorrect button/key is inputted. The original version - Simon Says - displays the correct button that should have been clicked along with a sound that indicates an incorrect key has been inputted. The implementation of DNA Says makes the entire screen flash white 3 times and outputs a harmonic combination of notes that indicate an incorrect input. 
\\
\par Along with all the differences that truly make the game DNA Says truly unique, there are numerous similarities as the essence of the game is the same. Both implementations of the game have a main menu that allow the user to enter a mode and play the game. During a game, there is a score icon which displays the current score and there is also an exit button which will allow the user to return to the main menu.  

				
\section{Unit Testing Plan}
		
\subsection{Unit testing of internal functions}
		
\subsection{Unit testing of output files}		
\bibliographystyle{plainnat}
\bibliography{SRS}
\newpage
\section{Appendix}
This is where you can place additional information.
\subsection{Symbolic Parameters}
The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.
\subsection{Usability Survey Questions?}
This is a section that would be appropriate for some teams.
\end{document}